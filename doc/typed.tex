\documentclass[main.tex]{subfiles}
\begin{document}

\section{\typedlambdalvar}
\usingnamespace{lvar}

\typedlambdalvar is defined over an abstract domain $\mathcal{D}$ which forms a lattice. We write $\botD$ and $\topD$ for the minimum and maximum elements, $\sqsubseteqD$ for its partial order, and $\sqcupD$ for the maximum.

\paragraph*{Terms}
Terms ($\tm{L}$, $\tm{M}$, $\tm{N}$) are defined by the following grammar:
\[
  \begin{array}{lrll}
  \tm{L}, \tm{M}, \tm{N}
  & \coloneqq & \tm{x}
    \sep        \tm{\lambda x.M}
    \sep        \tm{M\;N}                     & \text{functions} \\
  & \sep      & \tm{l}                        
    \sep        \tm{d}
    \sep        \tmJ
    \sep        \tm{K}                        & \text{constants} \\
  & \sep      & \tm{\unit}                    
    \sep        \tm{\letunit{M}{N}}           & \text{units} \\
  & \sep      & \tm{\pair{M}{N}}              
    \sep        \tm{\letpair{x}{y}{M}{N}}     & \text{pairs}
  \\
  \\
  \tm{K}
  & \coloneqq & \tm{\lvarnew}
    \sep        \tm{\lvarfreeze}
    \sep        \tm{\lvarget}
    \sep        \tm{\lvarput}
\end{array}
\]
Let $\tm{x}$, $\tm{y}$, and $\tm{z}$ range over variable names. The term language is the standard $\lambda$-calculus with products and units, extended with LVars~\citep{kuper15}. Let $\tm{l}$ range over location names. Let $\tm{d}$ range over \emph{domain values} from the domain $\mathcal{D}$. Finally, let $\tmJ$ range over \emph{thresholds}. A~threshold $\tmJ$ is a subset of $\mathcal{D}$. A~threshold is pair-wise incompatible, written $\incomp(\tmJ)$, if for all $\tm{d},\tm{d'}\in\mathcal{D}$, if $\tm{d}\neq\tm{d'}$ then $\tm{d}\sqcup\tm{d'}=\tm{\topD}$.

\paragraph*{Configurations}
Configurations ($\tm{C}$), stores ($\tm{S}$), states ($\tm{p}$), and status bits ($\tm{\frz}$) are defined by the following grammar:
\[
\begin{array}{lrll}
  \tm{C}
  & \coloneqq & \tm{\config{M}{S}} & \text{configurations}
  \\
  \tm{S}
  & \coloneqq & \tm{\storeemp}
    \sep        \tm{\storeext{S}{l}{p}} & \text{stores}
  \\
  \tm{p}
  & \coloneqq & \tm{\langle \frz, d \rangle} & \text{states}
  \\
  \tm{\frz}
  & \coloneqq & \tm{\true}
    \sep        \tm{\false}
                                    & \text{status bits}
  \end{array}
\]
A~configuration $\tm{\config{M}{S}}$ consists of a term $\tm{M}$ and a store $\tm{S}$. A~store is a partial function from locations $\tm{l}$ to states $\tm{p}$. A~state consists of a domain value $\tm{d}$ and a status bit $\tm{\frz}$. The status bit records if that particular location has been frozen. We write $\tm{\storeext{S}{l}{p}}$ for the \emph{extension} of a store $\tm{S}$ with state $\tm{p}$ at a \emph{fresh} location $\tm{l}$. We write $\tm{\storeupd{S}{l}{p}}$ for the \emph{update} of a store with state $\tm{p}$ at an \emph{existing} location $\tm{l}$.

We write $\tm{\frz}\sqcupB\tm{\frz'}$ for the maximum on status bits, which is standard Boolean disjunction, and $\tm{\frz}\sqsubseteqB\tm{\frz'}$ for the \emph{total} order on status bits, which is standard Boolean implication.

\paragraph*{Syntactic sugar}
We use syntactic sugar to make terms more readable: we write $\tm{\andthen{M}{N}}$ in place of $\tm{\letunit{M}{N}}$, $\tm{\letbind{x}{M}{N}}$ in place of $\tm{(\lambda x.N)\;M}$, and pattern matching functions $\tm{\lambda\unit.M}$ in place of $\tm{\lambda z.\letunit{z}{M}}$ and $\tm{\lambda\pair{x}{y}.M}$ in place of $\tm{\lambda z.\letpair{x}{y}{z}{M}}$.

\paragraph{Operational semantics}
\label{sec:lvar-semantics}
\begin{mathpar}
  \begin{array}{lrll}
    \tm{V}, \tm{W}
    & \coloneqq & \tm{\lambda x.M}
      \sep        \tm{l}
      \sep        \tm{d}
      \sep        \tmJ
      \sep        \tm{K}
      \sep        \tm{\unit}
      \sep        \tm{\pair{V}{W}}
    \\
    \tm{E}
    & \coloneqq & \tm{\hole}
      \sep        \tm{M\; E}
      \sep        \tm{E\; M}
      \sep        \tm{(M, E)}
      \sep        \tm{(E, M)} \\
    & \sep      & \tm{\letunit{E}{M}}
      \sep        \tm{\letpair{x}{y}{E}{M}}
  \end{array}
\end{mathpar}

\input{fig/semantics}
See~\cref{fig:semantics}.

\paragraph*{Types}
Types ($\ty{T}$, $\ty{U}$),  and typing environments ($\ty{\Gamma}$) are defined by the following grammar:
\[
\begin{array}{lrll}
  \ty{T}, \ty{U}
  & \coloneqq & \ty{\tyunit}        & \text{units} \\
  & \sep      & \ty{\typrod{T}{U}}  & \text{pairs} \\
  & \sep      & \ty{\tyfun{T}{U}}   & \text{functions}\\
  & \sep      & \ty{\tyD{d}}        & \text{domain values }{\sqsubseteq d}\\
  & \sep      & \ty{\tyL{\frz}{d}}  & \text{location with values }{\sqsubseteq d}\\
  & \sep      & \ty{\tyJ}           & \text{thresholds}
  \\
  \ty{\Gamma}
  & \coloneqq & \ty{\emptyenv}
    \sep        \ty{\ty{\Gamma},\tmty{x}{T}}
                                    & \text{typing environments}
\end{array}
\]
Types $\ty{\tyunit}$, $\ty{\typrod{T}{U}}$, and $\ty{\tyfun{T}{U}}$ are the standard unit, pair, and function types.
The type $\tyD{d}$ types domain values with the upper bound $d$.
The type $\tyL{\frz}{d}$ types locations which store values of type $\tyD{d}$.
Thresholds occur on both the type- and term-level. Each threshold type $\tyJ$ has only one inhabitant, which is the same threshold $\tmJ$ on the term-level.

We extend $\sqcupD$ and $\sqsubseteqD$ to types and environments, see~\cref{fig:lattice}.
The operation $\sqcupT$ takes two types or typing environments with identical structure \emph{up to domain bounds}, and returns the type or typing environment with the pointwise maximum of each domain bound. Notably, \emph{status bits are unaffected by $\sqcupT$}.
The relation $\sqsubseteqT$ takes two types or typing environments with identical structure up to domain bounds \emph{and status bits}, and checks if each domain bound or status bit in the first argument is smaller than the corresponding domain bound or status bit in the second argument.

\input{fig/lattice}

\paragraph{Typing rules}%
\label{sec:lvar-typing}
\input{fig/typing}
See~\cref{fig:typing}.

\paragraph{Subject reduction}
\begin{lemma}[Subject reduction, $\red$]
  \hfill\\
  If $\seq{\ty{\Gamma}}{C}{T}$ and $\tm{C}\red\tm{C'}$, then $\seq{\ty{\Gamma}}{C}{T}$.
\end{lemma}
\begin{theorem}[Subject reduction, $\rede$]
  \hfill\\
  If $\seq{\ty{\Gamma}}{C}{T}$ and $\tm{C}\red\tm{C'}$, then $\seq{\ty{\Gamma}}{C}{T}$.
\end{theorem}
\input{fig/subject-reduction-red}

\paragraph{Progress}
\begin{theorem}[Progress, $\red$]
\end{theorem}
\begin{theorem}[Progress, $\rede$]
\end{theorem}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
