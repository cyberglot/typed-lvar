\documentclass[main.tex]{subfiles}
\begin{document}

\section{\typedlambdalvar calculus}
\usingnamespace{lvar}

\subsection{Syntax}%
\typedlambdalvar is defined over an abstract domain $\mathcal{D}$ which forms a lattice. We write $\bot$ and $\top$ for the minimum and maximum elements, $\sqsubseteq$ for its partial order, and $\sqcup$ for the \emph{maximum}.

\paragraph*{Types}
\[
\begin{array}{lrll}
  \ty{T}, \ty{U}
  & \coloneqq & \ty{\tyunit}        & \text{units} \\
  & \sep      & \ty{\typrod{T}{U}}  & \text{pairs} \\
  & \sep      & \ty{\tyfun{T}{U}}   & \text{functions}\\
  & \sep      & \ty{\tyJ}           & \text{thresholds} \\
  & \sep      & \ty{\tyD{d}}        & \text{domain values }{\sqsubseteq d}\\
  & \sep      & \ty{\tyL{d}}        & \text{location with values }{\sqsubseteq d}
  \\
  \\
  \ty{\Gamma}
  & \coloneqq & \multicolumn{2}{l}{\ty{\emptyenv} \sep \ty{\ty{\Gamma},\tmty{x}{T}}}
\end{array}
\]
We write $\ty{T}\sqcup\ty{U}$ for the type with the maximum domain bound from either $\ty{T}$ or $\ty{U}$ at each subtype $\tyD{d}$ and $\tyL{d}$. The operation is only defined if the structure of $\ty{T}$ and $\ty{U}$ is identical \emph{up to domain bounds}. Similarly for $\ty{\Gamma}\sqcup\ty{\Gamma'}$:
\[
  \setlength{\arraycolsep}{2pt}
  \begin{array}{lclcl}
    \ty{\tyunit} & \sqcup & \ty{\tyunit}
    & = & \ty{\tyunit}
    \\
    \ty{\typrod{T}{U}} & \sqcup & \ty{\typrod{T'}{U'}}
    & = & \typrod{(\ty{T}\sqcup\ty{T'})}{(\ty{U}\sqcup\ty{U'})}
    \\
    \ty{\tyfun{T}{U}} & \sqcup & \ty{\tyfun{T'}{U'}}
    & = & \tyfun{(\ty{T}\sqcup\ty{T'})}{(\ty{U}\sqcup\ty{U'})}
    \\
    \tyJ & \sqcup & \tyJ
    & = & \tyJ
    \\
    \tyD{d} & \sqcup & \tyD{d'}
    & = & \tyD{{d}\sqcup{d'}}
    \\
    \tyL{d} & \sqcup & \tyL{d'}
    & = & \tyL{{d}\sqcup{d'}}
    \\
    \\
    \ty{\emptyenv} & \sqcup & \ty{\emptyenv}
    & = & \ty{\emptyenv}
    \\
    \ty{\Gamma},\tmty{x}{T} & \sqcup & \ty{\Gamma'},\tmty{x}{U}
    & = & \ty{\Gamma}\sqcup\ty{\Gamma'},\tm{x}:{\ty{T}\sqcup\ty{U}}
  \end{array}
\]

\paragraph*{Terms}
\[
  \begin{array}{lrll}
  \tm{L}, \tm{M}, \tm{N}
  & \coloneqq & \tm{x}
    \sep        \tm{\lambda x.M}
    \sep        \tm{M\;N}                     & \text{functions} \\
  & \sep      & \tm{K}                        
    \sep        \tm{l}
    \sep        \tmJ
    \sep        \tm{d}                        & \text{constants} \\
  & \sep      & \tm{\unit}                    
    \sep        \tm{\letunit{M}{N}}           & \text{units} \\
  & \sep      & \tm{\pair{M}{N}}              
    \sep        \tm{\letpair{x}{y}{M}{N}}     & \text{pairs}
  \\
  \\
  \tm{K}
  & \coloneqq & \tm{\lvarnew}
    \sep        \tm{\lvarfreeze}
    \sep        \tm{\lvarget}
    \sep        \tm{\lvarput}
\end{array}
\]

\paragraph*{Thresholds}
Thresholds are \emph{singletons}, \ie they occur on both the term- and the type-level, and the type of a threshold $\tmJ$ is that same threshold $\tyJ$. 

A~threshold $\mathcal{J}$ is a subset of $\mathcal{D}$ where all elements are pair-wise incompatible, \ie for all $d,d'\in\mathcal{D}$, if ${d}\neq{d'}$ then ${d}\sqcup{d'}={\top}$.
A~domain value $d$ is below a threshold $\mathcal{J}$, written ${d}\sqsubseteq\mathcal{J}$, if there exists a ${d'}\in\mathcal{J}$ such that ${d}\sqsubseteq{d'}$.

\paragraph*{Syntactic sugar}
We use syntactic sugar to make terms more readable: we write $\tm{\andthen{M}{N}}$ in place of $\tm{\letunit{M}{N}}$, $\tm{\letbind{x}{M}{N}}$ in place of $\tm{(\lambda x.N)\;M}$, and pattern matching functions $\tm{\lambda\unit.M}$ in place of $\tm{\lambda z.\letunit{z}{M}}$ and $\tm{\lambda\pair{x}{y}.M}$ in place of $\tm{\lambda z.\letpair{x}{y}{z}{M}}$. Finally, we use $\tm{\lvarrun}$ in place of the idiom $\tm{\lambda x.\letbind{l}{\lvarnew}{\letunit{x\;l}{\lvarfreeze\;l}}}$.

\paragraph*{Configurations}
\[
\begin{array}{lrll}
  \tm{B}
  & \coloneqq & \tm{1}
    \sep        \tm{0} & \text{status bits}
  \\
  \tm{s}
  & \coloneqq & \tm{\langle B, d \rangle}
  \\
  \tm{S}
  & \coloneqq & \tm{\emptyenv}
    \sep        \tm{S, l \mapsto s} & \text{stores}
  \\
  \tm{C}
  & \coloneqq & \tm{\config{M}{S}} & \text{configurations}
\end{array}
\]

\paragraph*{Values and evaluation contexts}
\[
\begin{array}{lrll}
  \tm{V}, \tm{W}
  & \coloneqq & \tm{l}
    \sep        \tm{J}
    \sep        \tm{s}
    \sep        \tm{\lambda x.M}
    \sep        \tm{\unit}
    \sep        \tm{\pair{V}{W}}
  \\
  \tm{E}
  & \coloneqq & \tm{\hole}
    \sep        \tm{V\; E}
    \sep        \tm{E\; V}
    \sep        \tm{(V, E)}
    \sep        \tm{(E, V)} \\
  & \sep      & \tm{\letunit{E}{M}}
    \sep        \tm{\letpair{x}{y}{E}{M}}
\end{array}
\]

\subsection{Operational semantics}
\label{sec:lvar-semantics}
\input{fig/semantics}
See~\cref{fig:semantics}.

Recall that the evaluation contexts for pairs are $\tm{(V, E)}$ and $\tm{(E, V)}$. Consequently, we can only apply \LabTirName{E-Lift} if either of the components of the pair has already reduced to a value. If both components can still reduce, we are forced to apply \LabTirName{E-Par-Pair}, which reduces both sides in parallel. Similarly for function applications.

\subsection{Typing rules}%
\label{sec:lvar-typing}
\input{fig/typing}
See~\cref{fig:typing}.

\section{Metatheory of \typedlambdalvar calculus}

\subsection{Translation to \lambdalvar  from \typedlambdalvar}

\definition[Ordering of stores]{
  We define a binary operator $\sqcup_S~: D_S \times D_S \rightarrow D_S$ as follows:
  \begin{mathpar}
  \begin{array}{lcll}
    (0, d)   \sqcup_S  (0, d')   & = & (0, d \sqcup d')  \\
    (1, d)   \sqcup_S  (1, d')   & = & (1, d')  \\
    (0, d)   \sqcup_S  (1, d')   & = & (1, d')  \\
    (1, d)   \sqcup_S  (0, d')   & = & (1, d')  \\
  \end{array}\\
\end{mathpar}
}

\todo{%
  The translation function $\trans{\cdot}$ should have a tight operational correspondence, \ie terms in \typedlambdalvar should reduce in the same number of steps when translated to \lambdalvar, and should not add or remove synchronisation.}

\todo{%
  The translation function below is unfinished. You probably want to replace each occurrence of an $e$-style variable with a recursive call?}

\begin{mathpar}
  \begin{array}{lcll}
    \tm{\trans{\config{\lvarget\;l\;\tmJ}{S}}}
    & = & \configl{S}{\lvarget\;l\;P}
    \\ & & \multicolumn{2}{l}{\text{where } p_1 \cong s \text{ and } P \cong \tmJ}
    \\
    \tm{\trans{\config{\lvarput\;l\;d'}{S}}}
    & = & \configl{S}{\lvarput_{i}\;l}
    \\ & & \multicolumn{2}{l}{\text{where }u_{p_{i}}\coloneqq\lambda{d_i}.d\sqcup{d_i}}
    \\
    \tm{\trans{\config{\lvarnew}{S}}}
    & = & \configl{S}{\lvarnew}
    \\
    \tm{\trans{\config{\lvarfreeze\;l}{S}}}
    & = & \configl{S}{\lvarfreeze\;l}
    \\
    \tm{\trans{\config{\lambda x.M}{S}}}
    & = & \configl{S}{\lambda x.e}
    \\
    \tm{\trans{\config{M\;N}{S}}}
    & = & \configl{S}{e\;e'}
    \\
    \tm{\trans{\config{()}{S}}}
    & = & \configl{S}{()}
    \\
    \tm{\trans{\config{\letunit{M}{N}}{S}}}
    & = & \configl{S}{\lambda ().e}
    \\
    \tm{\trans{\config{\pair{M}{N}}{S}}}
    & = & \configl{S}{(\lambda x. \lambda y.\lambda f. f x y)\;e\;e'}
    \\
    \tm{\trans{\config{\letpair{x}{y}{M}{N}}{S}}}
    & = & \configl{S}{e\;(\lambda x.\lambda y. e')}
    \\
    \tm{\trans{\config{M}{S, l \mapsto (0, d)}}}
    & = & \configl{S[l \mapsto (d,\tt{false})]}{e}
    \\
    \tm{\trans{\config{M}{S, l \mapsto (1, d)}}}
    & = & \configl{S[l \mapsto (d,\tt{true})]}{e}
  \end{array}
\end{mathpar}

\begin{lemma}[Translation, \typedlambdalvar  $\rightsquigarrow$ \lambdalvar]
  For any translation $\zeta$,
  \begin{itemize}
    \item if $C \red C'$ and $\sigma \hookrightarrow \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$;
    \item if $C \rede C'$ and $\sigma \mapsto \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$.
  \end{itemize}
\end{lemma}

\begin{proof}
  By induction on the structure of $C$. All cases are straight-forward, except
  for the introduction and elimination of pairs.

  \begin{case}{%
      $C = \config{\lvarerror}{S}$,
      $\sigma = \configl{S}{\lvarerror}$}
    $C$ and $\sigma$ cannot step. Hence, the translation is vacuously valid.
  \end{case}

  \begin{case}{%
      $C = \config{\lvarget\;l\;J}{S}$,
      $\sigma = \configl{S}{\lvarget\;l\;P}$}
    Given the operational semantics, $C$ steps to $C' = \config{s'}{S, l \mapsto (b, d)}$. And given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to $\sigma' = \configl{S}{p_2}$. Applying $\zeta (C')$, we get $\configl{S}{p_2}$. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced. Hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $C = \config{\lvarput\;l\;d'}{S}$,
      $\sigma = \configl{S}{\lvarput_{i}\;l}$}
    Given the operational semantics, $C$ can either error or take a step.
    \begin{subcase}{$C' = \config{s'}{S, l \mapsto s'}$}
      Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to $\sigma' = \configl{S}{p_2}$ if $d \sqcup d_{i} \neq \top$, which is exactly the same as applying $\zeta$ to $C'$. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced.
    \end{subcase}
    \begin{subcase}{$C' = \lvarerror$}
      Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to $\sigma' = \lvarerror$ if $d \sqcup d_{i} = \top$, which is exactly the same as applying $\zeta$ to $C'$. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced. Hence, this translation is valid.
    \end{subcase}
  \end{case}

  \begin{case}{%
      $C = \config{\lvarnew}{S}$,
      $\sigma = \configl{S}{\lvarnew}$}
    $C'$ steps to $\config{l}{S, l \mapsto (0, \bot)}$ which is equivalent to $\configl{S[l \mapsto (\bot, false)]}{l}$, as showed in the last two cases of the proof. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced. Hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $C = \config{\lvarfreeze}{S}$,
      $\sigma = \configl{S}{\lvarfreeze}$}
    $C'$ steps to $\config{d}{S, l \mapsto (1, d)}$ which is equivalent to $\configl{S[l \mapsto (p, true)]}{p}$, as showed in the last two cases of the proof. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced. Hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $C = \config{\lambda x.M}{S}$,
      $\sigma = \configl{S}{\lambda x.e}$}
    $C$ and $\sigma$ do not step since lambda abstractions are values. Also, $C$ and $\sigma$ are immediately equivalent up to $\alpha$-equivalence.
  \end{case}

  \begin{case}{%
      $\config{M\;N}{S}$,
      $ \sigma = \configl{S}{e\;e'}$}
    The application case is simple, where expressions take one step each in parallel in both languages. \typedlambdalvar maintains the same number of steps and there is no unwanted synchronisation introduced. Hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $ C = \config{()}{S}$,
      $\sigma = \configl{S}{()}$}
    $C$ and $\sigma$ do not step since unit is a value. Also, $C$ and $\sigma$ are immediately equivalent.
  \end{case}

  \begin{case}{%
      $ C = \config{\letunit{M}{N}}{S}$,
      $\sigma = \configl{S}{(\lambda (). e')  e}$}
    The \lambdalvar calculus does not provide an elimination rule for unit, since it introduces an explicit synchronisation construct. However, such construct is easily defined by forcing $e$ to evaluate before $e'$ via the introduction and elimination a lambda abstraction. \citet{kuper15} informally uses a generalised version of this construct. Both $C$ and $\sigma$ steps to the outermost expression, $N$ and $e'$, respectively. Explicit unit elimination here is used to synchronise and necessary for \texttt{runLVars} to work. No extra steps are taken in the translation, hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $ C = \config{\pair{M}{N}}{S}$,
      $\sigma = \configl{S}{(\lambda x. \lambda y.\lambda f. f x y)\;e\;e'}$}
    In \typedlambdalvar, pair components are evaluated in parallel and the next step will be blocked until both components are evaluated to a value. The \lambdalvar calculus does not provide pairs, therefore we encode them using lambda abstractions. In our encoding, a function takes two values and returns function that takes both values. According to the semantics of the \lambdalvar  calculus, when those two expressions are passed to a function, they are evaluated in parallel. Hence, our encoding does not introduce synchronisation, blocking the next step unnecessarily. The translation maintains the same number of steps and, hence, is valid.
  \end{case}

  \begin{case}{%
      $C = \config{\letpair{x}{y}{M}{N}}{S}$,
      $\sigma = \configl{S}{e' \;(\lambda x.\lambda y. e)}$}
    In \typedlambdalvar, the elimination rule for pairs require that both components are values, and those are substituted within the next computation by using two fresh variables. Given that we encoded pairs as a function that takes a function with two arguments, we need to create said function in order to eliminate pairs. The eliminating function has to make the values within the pair available to the next computation, in this case $e'$. According to the \lambdalvar calculus, parameters must be fully evaluated before being passed on to a lambda abstraction - fact easily verifiable since \lambdalvar has call-by-value semantics. Therefore, our encoding does not introduce synchronisation, blocking the next step unnecessarily, and maintains the same number of steps. Hence, this translation is valid.
  \end{case}

  \begin{case}{%
      $C = \config{M}{S, l \mapsto (0, d)}$,
      $\sigma = \configl{S[l \mapsto (d, \tt{false})]}{e}$}
    The encoding of LVar's writeability status in \typedlambdalvar uses $0$ and $1$,
    while in \lambdalvar, they are encoded as regular booleans. Irregardless of the most
    common representation of booleans as numbers, the LVar should be initialised
    with one status and switch to a different one once frozen, which happens in
    both \lambdalvar and \typedlambdalvar.
  \end{case}

  \begin{case}{%
      $C = \config{M}{S, l \mapsto (1, d)}$,
      $ \sigma = \configl{S[l \mapsto (d, \tt{true})]}{e}$}
    Follows an analogous argument as previous case.
  \end{case}

  \remember{Add case for lifted evaluation contexts.}
\end{proof}


\subsection{Determinism}

Given the translation of \typedlambdalvar  into \lambdalvar  is valid, we can infer that \typedlambdalvar  is quasi-deterministic as well. Here, we restate definitions leading to the quasi-determinism proof as stated in \citet{kuper15}.
\remember{Please don't restate the proofs.}

\definition[Permutation]{
  A~permutation function is a function $\pi : \ty{L} \rightarrow \ty{L}$ such that:
\begin{itemize}
\item it is invertible, that is, there is an inverse function $\pi^{-1}i : \ty{L} \rightarrow \ty{L}$ with the property that $\pi(l) = l'$ iff $\pi^{-1}(l') = l$;
\item it is the identity on all but finitely many elements of $\ty{L}$.
\end{itemize}
}

\definition[Permutation of expressions]{
  A~permutation of an expression $M$ is a function $\pi$ defined as follows:
 \todo{find the base case where something happens?}
  \begin{mathpar}
  \begin{array}{lcll}
    \pi(\lvarget\;l\;J)       & = & \lvarget\;\pi(l)\;\pi(J) \\
    \pi(\lvarput\;l\;d')      & = & \lvarput\;\pi(l) \\
    \pi(\lvarnew)                & = & \lvarnew \\
    \pi(\lvarfreeze\;l)       & = & \lvarfreeze\;\pi(l) \\
    \pi(\lambda x.M)         & = & \lambda x.\pi(M) \\
    \pi(M\;N)                      & = & \pi(M) \; \pi(N)\\
    \pi(())                            & = & () \\
    \pi(x)                            & = & x \\
    \pi(\letunit{M}{N})      & = & \letunit{\pi(M)}{\pi(N)} \\
    \pi(\pair{M}{N})           & = &  \pair{\pi(M)}{\pi(N)} \\
    \pi(\letpair{x}{y}{M}{N}) & = & \letpair{x}{y}{\pi(M)}{\pi(N)} \\
  \end{array}\\
\end{mathpar}}

\definition{Permutation of a store}

\definition{Permutation of configurations}

\lemma{Permutability}

\lemma{Internal Determinism}

\lemma{Strong Confluence}

\lemma{Confluence}

\theorem{Quasi-Determinism}

\subsection{Type safety}

\theorem{Progress}

\theorem{Preservation}

\corollary{Type Safety}

\subsection{Fully deterministic programming with LVars}

In this section, we prove that \typedlambdalvar  is deterministic, which is the main
contribution of this work. We proceed by proving that all \lvarerror  states
within the \typedlambdalvar calculus are not typeable given our type rules.

\theorem{Untypeable \lvarerror s}
\corollary{Full Determinism}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
