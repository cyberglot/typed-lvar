\documentclass[main.tex]{subfiles}
\begin{document}

\section{\typedlvar calculus}
\usingnamespace{llam}

Given a set $D$, let $\mathbb{D}$ be a 4-tuple $(D, \sqcup_{D}, \bot_{D}, \top_{D})$, and let $J$ range over threshold sets, where $J \subseteq D$ such that $\forall d, d' \in J. d \sqcup d' = \top_{D}$.

\subsection{Syntax}
\label{sec:llam-syntax}

\paragraph{Types and environments}
\[
\begin{array}{lcll}
  \ty{T}, \ty{U}
  & \coloneqq & \ty{\tyunit}        & \text{unit} \\
  & \sep      & \ty{\typrod{T}{U}}  & \text{product} \\
  & \sep      & \ty{\tyfun{T}{U}}   & \lambda \text{ abstraction}\\
  & \sep      & \ty{\tyJ}         & \text{threshold sets} \\
  & \sep      & \ty{\tyD{d}}        & \text{elements }d\text{ in }D\text{ such that }\bigsqcup{D^d}=d\\
  & \sep      & \ty{\tyL{d}}        & \text{locations (indexed by }d\text{) of elements in }\tyD{d}\\
  \\
  \ty{\Gamma}
  & \coloneqq & \ty{\emptyenv}                 & \text{empty environment}\\
  & \sep      & \ty{\ty{\Gamma},\tmty{x}{T}}   & \text{environment extension} \\
\end{array}
\]

\remember{Define the incompatibility criterion for threshold sets.}

\paragraph{Term-level syntax}
\[
\begin{array}{lcll}
  \textit{terms }\tm{L}, \tm{M}, \tm{N}
  & \coloneqq & \tm{x}                        & \text{variables} \\
  & \sep      & \tm{l} \sep \tm{J} \sep \tm{d} \sep \tm{\lambda x.M}
                                              & \text{values} \\
  & \sep      & \tm{K}                        & \text{constants} \\                                              
  & \sep      & \tm{M\;N}                     & \text{application} \\
  & \sep      & \tm{\unit}                    & \text{unit introduction} \\
  & \sep      & \tm{\letunit{M}{N}}           & \text{unit elimination} \\
  & \sep      & \tm{\pair{V}{W}}              & \text{product introduction} \\
  & \sep      & \tm{\letpair{x}{y}{M}{N}}     & \text{product elimination}\\
  \\
  \textit{status bits }\tm{B}
  & \coloneqq & \tm{1}                        & \text{frozen LVar} \\
  & \sep      & \tm{0}                        & \text{non-frozen LVar} \\
  \\
  \textit{state } \tm{s}
  & \coloneqq & \tm{\langle B, d \rangle}     & \text{states} \\
  \\
  \textit{stores } \tm{S}
  & \coloneqq & \tm{\emptyenv}                & \text{empty store} \\
  & \sep      & \tm{S, l \mapsto s}           & \text{store extension} \\
  & \sep      & \top                          & \text{top} \\
  \\
  \textit{configurations }\tm{C}
  & \coloneqq & \tm{\config{M}{S}}            & \text{programs are composed of
                                                    terms and store} \\
  & \sep      & \tm{\lvarerror}               & \text{runtime crash} \\
  \\
  \textit{values }\tm{V}, \tm{W}
  & \coloneqq & \tm{l}                        & \text{locations} \\
  & \sep      & \tm{J}                        & \text{threshold set} \\
  & \sep      & \tm{s}                        & \text{states} \\
  & \sep      & \tm{\lambda x.M}              & \lambda \text{ abstraction} \\
  & \sep      & \tm{\unit}                    & \text{unit} \\
  & \sep      & \tm{\pair{V}{W}}              & \text{product} \\
  \\
  \textit{constants }\tm{K}
  & \coloneqq & \tm{\lvarnew}                 & \text{allocate new LVar} \\
  & \sep      & \tm{\lvarfreeze}              & \text{freeze LVar} \\
  & \sep      & \tm{\lvarget}                 & \text{read threshold from
                                                  LVar} \\
  & \sep      & \tm{\lvarput}                 & \text{add value to LVar} \\
  \\
  \textit{evaluation contexts }\tm{E}
  & \coloneqq & \tm{\hole}                 \\
  & \sep      & \tm{V\; E}                 \\       
  & \sep      & \tm{E\; V}                 \\     
  & \sep      & \tm{(V, E)}                \\   
  & \sep      & \tm{(E, V)}                \\   
  & \sep      & \tm{\letunit{E}{M}}        \\                                                   
  & \sep      & \tm{\letpair{x}{y}{E}{M}}  \\   
\end{array}
\]

\subsection{Type System}%
\label{sec:llam-typing}

\begin{definition}
  A~domain $\ty{d}$ is below a threshold set $\tyJ$, written $\ty{d}\sqsubseteq\tyJ$, if there exists a $\ty{d'}\in\tyJ$ such that $\ty{d}\sqsubseteq\ty{d'}$.
\end{definition}

\begin{definition}[$\ty{T}\sqcup\ty{U}$]
  We can take the maximum of the domain bounds in two types $\ty{T}$ and $\ty{U}$ as $\ty{T}\sqcup\ty{U}$ if the structure of the types $\ty{T}$ and $\ty{U}$ is identical up to the domain bounds:
  \[
    \setlength{\arraycolsep}{2pt}
    \begin{array}{lclcl}
      \ty{\tyunit} & \sqcup & \ty{\tyunit}
      & = & \ty{\tyunit}
      \\
      \ty{\typrod{T}{U}} & \sqcup & \ty{\typrod{T'}{U'}}
      & = & \typrod{(\ty{T}\sqcup\ty{T'})}{(\ty{U}\sqcup\ty{U'})}
      \\
      \ty{\tyfun{T}{U}} & \sqcup & \ty{\tyfun{T'}{U'}}
      & = & \tyfun{(\ty{T}\sqcup\ty{T'})}{(\ty{U}\sqcup\ty{U'})}
      \\
      \tyJ & \sqcup & \tyJ
      & = & \tyJ
      \\
      \tyD{d} & \sqcup & \tyD{d'}
      & = & \tyD{{d}\sqcup{d'}}
      \\
      \tyL{d} & \sqcup & \tyL{d'}
      & = & \tyL{{d}\sqcup{d'}}
    \end{array}
  \]
\end{definition}

\begin{definition}[$\ty{\Gamma}\sqcup\ty{\Delta}$]
  We can take the maximum of the domain bounds in two contexts $\ty{\Gamma}$ and $\ty{\Delta}$ as $\ty{\Gamma}\sqcup\ty{\Delta}$ if the structure of the contexts $\ty{\Gamma}$ and $\ty{\Delta}$ is identical up to the domain bounds.
  \[
    \setlength{\arraycolsep}{2pt}
    \begin{array}{lclcl}
      \ty{\emptyenv} & \sqcup & \ty{\emptyenv}
      & = & \ty{\emptyenv}
      \\
      \ty{\Gamma},\tmty{x}{T} & \sqcup & \ty{\Delta},\tmty{x}{U}
      & = & \ty{\Gamma}\sqcup\ty{\Delta},\tm{x}:{\ty{T}\sqcup\ty{U}}
    \end{array}
  \]
\end{definition}


\begin{mathpar}
  \inferrule*[lab=T-Var]{
  }{\seq{\tmty{x}{T}}{x}{T}}

  \inferrule*[lab=T-Lam]{
    \seq{\ty{\Gamma},\tmty{x}{T}}{M}{U}
  }{\seq{\ty{\Gamma}}{\lambda x.M}{\tyfun{T}{U}}}

  \inferrule*[lab=T-App]{
    \seq{\ty{\Gamma}}{M}{\tyfun{T}{U}}
    \\
    \seq{\ty{\Delta}}{N}{T}
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{M\;N}{U}}
  \\
  
  \inferrule*[lab=T-Unit]{
  }{\seq{\ty{\Gamma}}{\unit}{\tyunit}}

  \inferrule*[lab=T-LetUnit]{
    \seq{\ty{\Gamma}}{M}{\tyunit}
    \\
    \seq{\ty{\Delta}}{N}{T}
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{\letunit{M}{N}}{T}}
  \\
  
  \inferrule*[lab=T-Pair]{
    \seq{\ty{\Gamma}}{M}{T}
    \\
    \seq{\ty{\Delta}}{N}{U}
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{\pair{M}{N}}{\typrod{T}{U}}}

  \inferrule*[lab=T-LetPair]{
    \seq{\ty{\Gamma}}{M}{\typrod{T}{T'}}
    \\
    \seq{\ty{\Delta},\tmty{x}{T},\tmty{y}{T'}}{N}{U}
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{\letpair{x}{y}{M}{N}}{U}}
  \\

  \inferrule*[lab=T-Threshold]{
  }{\seq{\ty{\Gamma}}{\tmJ}{\tyJ}}

  \inferrule*[lab=T-New]{
  }{\seq{\ty{\Gamma}}{\lvarnew}{\tyL{\bot}}}

  \inferrule*[lab=T-Freeze]{
    \seq{\ty{\Gamma}}{M}{\tyL{d}}
  }{\seq{\ty{\Gamma}}{\lvarfreeze\;M}{\tyD{d}}}
  \\

  \inferrule*[lab=T-Get]{
    \seq{\ty{\Gamma}}{M}{\tyL{d}}
    \\
    \seq{\ty{\Delta}}{N}{\tyJ}
    \\
    \ty{d}\sqsubseteq\tyJ
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{\lvarget\;M\;N}{\tyD{d}}}

  \inferrule*[lab=T-Put]{
    \seq{\ty{\Gamma}}{M}{\tyL{d}}
    \\
    \seq{\ty{\Delta}}{N}{\tyD{d'}}
  }{\seq{\ty{\Gamma}\sqcup\ty{\Delta}}{\lvarput\;M\;N}{1}}
\end{mathpar}

\todo[inline,caption={Overestimation of upper bound due to weakening}]{%
  I~think we've got a bit of an issue with weakening. For instance, take \LabTirName{T-Unit}. It can be typed under an \emph{arbitrary} context $\Gamma$, which means that we can use it to set arbitrary upper bounds on the domain values and locations, which will then be merged into the main context. This means our upper bound need not be exact, but could be an over-estimate\dots I~don't actually think this will lead to problems with our proofs, since it'll never lead to an under-estimate, but it's something to keep in mind.}

\subsection{Operational semantics}
\label{sec:llam-semantics}

% \paragraph{Configuration-independent reductions}
\begin{mathpar}
  \begin{array}{llcl}
    \LabTirName{E-Lam}   & \tm{\config{(\lambda x.M)\;V}{S}}
                         & \red & \tm{\config{\subst{M}{V}{x}}{S}}
    \\
    \LabTirName{E-Unit}  & \tm{\config{\letunit{\unit}{M}}{S}}
                         & \red & \tm{\config{M}{S}}
    \\
    \LabTirName{E-Pair}  & \tm{\config{\letpair{x}{y}{\pair{V}{W}}{M}}{S}}
                         & \red & \tm{\config{\subst{\subst{M}{V}{x}}{W}{y}}{S}}
    \\
    \LabTirName{E-New}     & \tm{\config{\lvarnew}{S}}
                           & \red
                           & \tm{\config{l}{S, l \mapsto (0, \bot)}}
    \\
    \LabTirName{E-Freeze}  & \tm{\config{\lvarfreeze}{S, l \mapsto (b, d)}}
                           & \red
                           & \tm{\config{d}{S, l \mapsto (1, d)}}
    \end{array}
    \\
    \inferrule*[lab=E-Put]{
      d \sqcup d' \neq \top
  }{\tm{\config{\lvarput\;l\;d'}{S, l \mapsto \sts{0}{d}}} \red
    \tm{\config{()}{S, l \mapsto \sts{0}{d'}}}
  }
  \\
  \inferrule*[lab=E-Put-Err]{
    d \sqcup d' = \top
  }{\tm{\config{\lvarput\;l\;d'}{S, l \mapsto s}} \red
    \tm{\lvarerror}
  }
  \\
  \inferrule*[lab=E-Get]{
    d' \in J
    \\
    d' \sqsubseteq d
  }{\tm{\config{\lvarget\;l\;J}{S, l \mapsto \sts{b}{d}}} \red
    \tm{\config{d'}{S, l \mapsto \sts{b}{d}}}
  }\\
  \inferrule*[lab=E-Pair']{
    \tm{\config{M}{S}} \red \tm{\config{M'}{S'}}   
    \\
    \tm{\config{N}{S}} \red  \tm{\config{N'}{S''}}
  }{\tm{\config{\pair{M}{N}}{S}}
    \red
    \tm{\config{\pair{M'}{N'}}{S' \sqcup S''}}
  }\\
  \inferrule*[lab=E-App]{
    \tm{\config{M}{S}} \red \tm{\config{M'}{S'}}   
    \\
    \tm{\config{N}{S}} \red  \tm{\config{N'}{S''}}
  }{\tm{\config{M\;N}{S}}
    \red
    \tm{\config{M'\;N'}{S' \sqcup S''}}
  }\\
  \inferrule*[lab=E-Lift]{
    \config{M}{S} \red \config{N}{S'}   
  }{\tm{\confige{M}{S}}
    \rede
    \tm{\confige{N}{S'}}
  }\\
  
\end{mathpar}

\subsection{Syntatic sugar}

\begin{mathpar}
\inferrule*[lab=T-RunLVar]{
    \seq{\ty{\Gamma}}{M}{\tyfun{\tyL{d}}{()}}
  }{\seq{\ty{\Gamma}}{\lvarrun\;M}{\tyD{d}}}
  \\
  \begin{array}{llcl}
    \LabTirName{E-RunLVar} & \tm{\lvarrun\;M}
                           & \coloneqq
                           & \tm{(\lambda l.\letunit{M\;l}{\lvarfreeze\;l})\;\lvarnew}
  \end{array}
  \end{mathpar}

\section{Metatheory of \typedlvar calculus}

\subsection{Translation to \lvar  from \typedlvar}

\definition{A translation is a function $\zeta : C \rightarrow \sigma$,
such that:

\remember{Add partial-order rules for state $s$, where $s = (b, d)$.}
\begin{itemize}
\item it should maintain the same number of steps in $C$ when translated
  into $\sigma$;
\item it should not introduce synchronisation.
\end{itemize}
}

\begin{mathpar}
  \begin{array}{lcll}
    \zeta(\lvarerror)                       & = & \lvarerror \\
    \zeta(\config{\lvarget\;l\;J}{S})       & = & \configl{S}{\lvarget\;l\;P}
                                            & \text{where } p_1 \cong s \text{
                                              and } P \cong J \\
    \zeta(\config{\lvarput\;l\;d'}{S})      & = & \configl{S}{\lvarput_{i}\;l}
                                            & \text{where }u_{p_{i}}\coloneqq\lambda{d_i}.d\sqcup{d_i}  \\
    \zeta(\config{\lvarnew}{S})             & = & \configl{S}{\lvarnew} \\
    \zeta(\config{\lvarfreeze\;l}{S})       & = & \configl{S}{\lvarfreeze\;l} \\
    \zeta(\config{\lambda x.M}{S})          & = & \configl{S}{\lambda x.e} \\
    \zeta(\config{M\;N}{S})                 & = & \configl{S}{e\;e'} \\
    \zeta(\config{()}{S})                   & = & \configl{S}{()} \\
    \zeta(\config{\letunit{M}{N}}{S})       & = & \configl{S}{\lambda ().e} \\
    \zeta(\config{\pair{M}{N}}{S})          & = & \configl{S}{(\lambda x. \lambda y.
                                                   \lambda f. f x y)\;e\;e'} \\
    \zeta(\config{\letpair{x}{y}{M}{N}}{S}) & = & \configl{S}{e\;(\lambda x.
                                                   \lambda y. e')} \\
    \zeta(\config{M}{S, l \mapsto (0, d)})  & = & \configl{S[l \mapsto (d,
                                                  \tt{false})]}{e} \\
    \zeta(\config{M}{S, l \mapsto (1, d)})  & = & \configl{S[l \mapsto (d,
                                                  \tt{true})]}{e} \\
  \end{array}\\
\end{mathpar}

\begin{lemma}[Translation, \typedlvar  $\rightsquigarrow$
   \lvar]
  For any translation $\zeta$,
  \begin{itemize}
    \item if $C \red C'$ and $\sigma \hookrightarrow \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$;
    \item if $C \rede C'$ and $\sigma \mapsto \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$.
  \end{itemize}
\end{lemma}

\begin{proof}
  By induction on the structure of $C$. All cases are straight-forward, except
  for the introduction and elimination of pairs.

 \case{$C = \config{\lvarerror}{S}, \; \sigma = \configl{S}{\lvarerror}$.}\\
 $C$ and $\sigma$ cannot step. Hence, the translation is vacuously valid.\\

 % ----------------------

 \case{$C = \config{\lvarget\;l\;J}{S}, \; \sigma = \configl{S}{\lvarget\;l\;P}$.}\\
  Given the operational semantics, $C$ steps to $C' = \config{s'}{S, l \mapsto (b,
    d)}$.
  And given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
  $\sigma' = \configl{S}{p_2}$. Applying $\zeta (C')$, we get
  $\configl{S}{p_2}$. \typedlvar maintains the same number of steps and there is
  no unwanted synchronisation introduced. Hence, this translation is valid. \\

  % ----------------------

  \case{$C = \config{\lvarput\;l\;d'}{S}, \; \sigma = \configl{S}{\lvarput_{i}\;l}$.}\\
  Given the operational semantics, $C$ can either error or take a step.\\

    \subcase{$C' = \config{s'}{S, l \mapsto s'}$} \\
    Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
    $\sigma' = \configl{S}{p_2}$ if $d \sqcup d_{i} \neq \top$, which is exactly
    the same as applying $\zeta$ to $C'$. \typedlvar maintains the same number
    of steps and there is no unwanted synchronisation introduced. \\
    

    % ----------------------
    \subcase{$C' = \lvarerror$}\\
     Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
    $\sigma' = \lvarerror$ if $d \sqcup d_{i} = \top$, which is exactly
    the same as applying $\zeta$ to $C'$. \typedlvar maintains the same number
    of steps and there is no unwanted synchronisation introduced.

    Hence, this translation is valid. \\ 

  % ----------------------

  \case{$ C = \config{\lvarnew}{S}$, $\sigma = \configl{S}{\lvarnew}$}\\
  $C'$ steps to $\config{l}{S, l \mapsto (0, \bot)}$ which
  is equivalent to $\configl{S[l \mapsto (\bot, false)]}{l}$, as showed in the last two
  cases of the proof. \typedlvar maintains the same number of steps and there is
  no unwanted synchronisation introduced. Hence, this translation is valid.  \\
  
  % ----------------------
  \case{$ C = \config{\lvarfreeze}{S}$, $\sigma = \configl{S}{\lvarfreeze}$}\\
  $C'$ steps to $\config{d}{S, l \mapsto (1, d)}$ which
  is equivalent to $\configl{S[l \mapsto (p, true)]}{p}$, as showed in the last two
  cases of the proof. \typedlvar maintains the same number of steps and there is
  no unwanted synchronisation introduced. Hence, this translation is valid. \\
  
  % ----------------------

  \case{$C = \config{\lambda x.M}{S}$,
    $\sigma = \configl{S}{\lambda x.e}$}\\
  $C$ and $\sigma$ do not step since lambda abstractions are values. Also, $C$
  and $\sigma$ are immediately equivalent up to $\alpha$-equivalence.\\

  % ----------------------

  \case{$\config{M\;N}{S}$, $ \sigma = \configl{S}{e\;e'}$}\\
  The application case is simple, where expressions take one step each in
  parallel in both languages. \typedlvar maintains the same number of steps and
  there is no unwanted synchronisation introduced. Hence, this translation is
  valid. \\ 

  % ----------------------

  \case{$ C = \config{()}{S}$, $\sigma = \configl{S}{()}$}\\
  $C$ and $\sigma$ do not step since unit is a value. Also, $C$
  and $\sigma$ are immediately equivalent.\\

  % ----------------------

  \case{$ C = \config{\letunit{M}{N}}{S}$,
    $\sigma = \configl{S}{(\lambda (). e')  e}$}\\
  The \lvar calculus does not provide an elimination rule for unit, since it
  introduces an explicit synchronisation construct. However, such construct is
  easily defined by forcing $e$ to evaluate before $e'$ via the introduction and
  elimination a lambda abstraction. Kuper'15 informally uses a generalised
  version of this construct. Both $C$ and $\sigma$ steps to the outermost
  expression, $N$ and $e'$, respectively. Explicit unit elimination here is used
  to synchronise and necessary for \tt{runLVars} to work. No extra steps are
  taken in the translation, hence, this translation is valid.\\

  % ----------------------
  
  \case{$ C = \config{\pair{M}{N}}{S}$,
    $\sigma = \configl{S}{(\lambda x. \lambda y.\lambda f. f x y)\;e\;e'}$} \\
  In \typedlvar, pair components are evaluated in parallel and the next step will
  be blocked until both components are evaluated to a value. The \lvar calculus
  does not provide pairs, therefore we encode them using lambda abstractions.
  In our encoding, a function takes two values and returns function that takes
  both values. According to the semantics of the \lvar  calculus, when those two
  expressions are passed to a function, they are evaluated in parallel. Hence,
  our encoding does not introduce synchronisation, blocking the next step
  unnecessarily. The translation maintains the same number of steps and, hence,
  is valid. \\
  
  % ----------------------
  \case{$C = \config{\letpair{x}{y}{M}{N}}{S}$,
    $\sigma = \configl{S}{e' \;(\lambda x.\lambda y. e)}$} \\
  In \typedlvar, the elimination rule for pairs require that both components are 
  values, and those are substituted within the next computation by using two
  fresh variables. Given that we encoded pairs as a function that takes a
  function with two arguments, we need to create said function in order to
  eliminate pairs. The eliminating function has to make the values within the
  pair available to the next computation, in this case $e'$. According to the
  \lvar calculus, parameters must be fully evaluated before being passed on to a
  lambda abstraction - fact easily verifiable since \lvar  has call-by-value
  semantics. Therefore, our encoding does not introduce synchronisation, blocking
  the next step unnecessarily, and maintains the same number of steps. Hence,
  this translation is valid. \\
  
  % ----------------------

  \remember{Add case for lifted environment contexts.}

  \case{$C = \config{M}{S, l \mapsto (0, d)} $,
    $ \sigma = \configl{S[l \mapsto (d, \tt{false})]}{e}$} \\
  The encoding of LVar's writeability status in \typedlvar uses $0$ and $1$,
  while in \lvar, they are encoded as regular booleans. Irregardless of the most
  common representation of booleans as numbers, the LVar should be initialised
  with one status and switch to a different one once frozen, which happens in
  both \lvar and \typedlvar.\\

  \case{$C = \config{M}{S, l \mapsto (1, d)}$,
    $ \sigma = \configl{S[l \mapsto (d, \tt{true})]}{e}$}\\
  Follows an analogous argument as previous case.
  
\end{proof}


\subsection{Determinism}

Given the translation of \typedlvar  into \lvar  is valid, we can infer that
\typedlvar  is quasi-deterministic as well. Here, we restate all proofs and
definitions leading to the quasi-determinism proof as stated in Kuper'15.

\definition{Permutation}

\definition{Permutation of an expression}

\definition{Permutation of a store}

\definition{Permutation of configurations}

\lemma{Permutability}

\lemma{Internal Determinism}

\lemma{Strong Confluence}

\lemma{Confluence}

\theorem{Quasi-Determinism}

\subsection{Type safety}

\theorem{Progress}

\theorem{Preservation}

\corollary{Type Safety}

\subsection{Fully deterministic programming with LVars}

In this section, we prove that \typedlvar  is deterministic, which is the main
contribution of this work. We proceed by proving that all \lvarerror  states
within the \typedlvar calculus are not typeable given our type rules.

\theorem{Untypeable \lvarerror s}
\corollary{Full Determinism}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
