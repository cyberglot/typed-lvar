\documentclass[main.tex]{subfiles}

\begin{document}

\section{Typed $\lambda_{\text{lvar}}$ calculus}
\usingnamespace{llam}

Given a set $D$, let $\mathbb{D}$ be a 4-tuple $(D, \sqcup_{D}, \bot_{D},
\top_{D})$, and let there be a function $incomp(d) \coloneqq \forall d' \in
D. (d' \neq d \Rightarrow d \sqcup d' = \top_{D})$ that models $\sqcup$-incompatibility among
elements of $\mathbb{J}$, i.e $\mathbb{J} = \{ d \in D \vert incomp(d) \}$.

\subsection{Syntax}
\label{sec:llam-syntax}

\paragraph{Types and environments}
\[
\begin{array}{lcll}
  \ty{T}, \ty{U}
  & \coloneqq & \ty{\tyunit}        & \text{unit} \\
  & \sep      & \ty{\typrod{T}{U}}  & \text{product} \\
  & \sep      & \ty{\tyfun{T}{U}}   & \lambda \text{ abstraction}\\
  & \sep      & \ty{\tyJ}           & \text{threshold set, where } \tyJ
                                      \subseteq \mathbb{J} \\
  & \sep      & \ty{\tyD{d}}        & \text{values } d \text{ in } D \text{ indexed by }
                                      \bigsqcup d\\
  & \sep      & \ty{\tyL{d}}        & \text{locations (indexed by } d \text{) of
                                      values in } \tyD{d}\\
  \\
  \ty{\Gamma}
  & \coloneqq & \ty{\emptyenv}                 & \text{empty environment}\\
  & \sep      & \ty{\tmty{x}{T}}               & \text{environment extension} \\
\end{array}
\]

\paragraph{Terms and Status bits}
\[
\begin{array}{lcll}
  \tm{L}, \tm{M}, \tm{N}
  & \coloneqq & \tm{x}                        & \text{variables} \\
  & \sep      & \tm{V}                        & \text{values} \\
  & \sep      & \tm{B}                        & \text{status bits}\\
  & \sep      & \tm{K}                        & \text{constants} \\                                              
  & \sep      & \tm{M\;N}                     & \text{parallel application} \\
  & \sep      & \tm{\unit}                    & \text{unit introduction} \\
  & \sep      & \tm{\letunit{M}{N}}           & \text{unit elimination} \\
  & \sep      & \tm{\pair{M}{N}}              & \text{product introduction} \\
  & \sep      & \tm{\letpair{x}{y}{M}{N}}     & \text{product elimination}\\
\end{array}
\]

\[
\begin{array}{lcll}
  \tm{B}
  & \coloneqq & \tm{1}                        & \text{frozen LVar} \\
  & \sep      & \tm{0}                        & \text{unfrozen LVar} \\
\end{array}
\]

\paragraph{Stores and Configurations}
\[
\begin{array}{lcll}
  \tm{S}
  & \coloneqq & \tm{\emptyenv}                & \text{empty store} \\
  & \sep      & \tm{S, l \mapsto (B, V)}      & \text{store extension} \\
  & \sep      & \top                          & \text{top} \\
  \end{array}
\]

\[
\begin{array}{lcll}
  \tm{C}
  & \coloneqq & \tm{\config{M}{S}}            & \text{programs are pairs of
                                                    terms and store} \\
  & \sep      & \tm{\lvarerror}               & \text{runtime crashes} \\
  \end{array}
\]

\paragraph{Values}
\[
\begin{array}{lcll}
  \tm{V}, \tm{W}
  & \coloneqq & \tm{l}                        & \text{locations} \\
  & \sep      & \tm{J}                        & \text{threshold set} \\
  & \sep      & \tm{(B, d)}                   & \text{states, where } D \text{
                                                is the distinguished set,
                                                and } d \in D\\
  & \sep      & \tm{\lambda x.M}              & \lambda \text{ abstraction} \\
  & \sep      & \tm{\unit}                    & \text{unit} \\
  & \sep      & \tm{\pair{M}{N}}              & \text{product} \\
\end{array}
\]

\paragraph{Constants}
\[
\begin{array}{lcll}
  \tm{K}
  & \coloneqq & \tm{\lvarnew}                 & \text{allocate new LVar} \\
  & \sep      & \tm{\lvarfreeze}              & \text{freeze LVar} \\
  & \sep      & \tm{\lvarget}                 & \text{read threshold from
                                                  LVar} \\
  & \sep      & \tm{\lvarput}                 & \text{add value to LVar} \\
\end{array}
\]

\paragraph{Evaluation Context}
\[
\begin{array}{lcll}
  \tm{E}
  & \coloneqq & \tm{\hole}                 \\
  & \sep      & \tm{V\; E}                 \\       
  & \sep      & \tm{E\; V}                 \\     
  & \sep      & \tm{(V, E)}                \\   
  & \sep      & \tm{(E, V)}                \\   
  & \sep      & \tm{\letunit{E}{M}}        \\                                                   
  & \sep      & \tm{\letpair{x}{y}{E}{M}}  \\   
\end{array}
\]

\subsection{Type System}%
\label{sec:llam-typing}

\begin{mathpar}
  \inferrule*[lab=T-Var]{
  }{\seq{\tmty{x}{T}}{x}{T}}

  \inferrule*[lab=T-Lam]{
    \seq{\ty{\Gamma},\tmty{x}{T}}{M}{U}
  }{\seq{\ty{\Gamma}}{\lambda x.M}{\tyfun{T}{U}}}

  \inferrule*[lab=T-App]{
    \seq{\ty{\Gamma}}{M}{\tyfun{T}{U}}
    \\
    \seq{\ty{\Gamma}}{N}{T}
  }{\seq{\ty{\Gamma}}{M\;N}{U}}
  \\
  
  \inferrule*[lab=T-Unit]{
  }{\seq{\emptyenv}{\unit}{\tyunit}}

  \inferrule*[lab=T-LetUnit]{
    \seq{\ty{\Gamma}}{M}{\tyunit}
    \\
    \seq{\ty{\Gamma}}{N}{T}
  }{\seq{\ty{\Gamma}}{\letunit{M}{N}}{T}}
  \\
  
  \inferrule*[lab=T-Pair]{
    \seq{\ty{\Gamma}}{M}{T}
    \\
    \seq{\ty{\Gamma}}{N}{U}
  }{\seq{\ty{\Gamma}}{\pair{M}{N}}{\typrod{T}{U}}}

  \inferrule*[lab=T-LetPair]{
    \seq{\ty{\Gamma}}{M}{\typrod{T}{T'}}
    \\
    \seq{\ty{\Gamma},\tmty{x}{T},\tmty{y}{T'}}{N}{U}
  }{\seq{\ty{\Gamma}}{\letpair{x}{y}{M}{N}}{U}}
  \\

  \inferrule*[lab=T-New]{
  }{\seq{\ty{\Gamma}, \tm{l} : \ty{\tyL{\bot}}}{\lvarnew}{\tyL{\bot}}}

  \inferrule*[lab=T-Freeze]{
    \seq{\ty{\Gamma}}{l}{\tyL{d}}
  }{\seq{\ty{\Gamma}}{\lvarfreeze\;l}{\tyD{d}}}
  \\

  \inferrule*[lab=T-Get]{
    \seq{\ty{\Gamma}}{l}{\tyL{d}}
    \\
    \seq{\ty{\Gamma}}{J}{\tyJ}
    \\
    \exists \ty{d'} \in \ty{\tyJ}. \ty{d} \sqsubseteq \ty{d'}
  }{\seq{\ty{\Gamma}}{\lvarget\;l\;J}{\tyD{d}}}

  \inferrule*[lab=T-Put]{
    \seq{\ty{\Gamma}}{l}{\tyL{d}}
    \\
    \seq{\ty{\Gamma}}{M}{\tyD{d'}}
  }{\seq{\ty{\Gamma}, \tm{l} : \ty{\tyL{d \sqcup d'}}}{\lvarput\;l\;M}{1}}
  \\

  
  
\end{mathpar}

\subsection{Operational semantics}
\label{sec:llam-semantics}

% \paragraph{Configuration-independent reductions}
\begin{mathpar}
  \begin{array}{llcl}
    \LabTirName{E-Lam}   & \tm{\config{(\lambda x.M)\;V}{S}}
                         & \red & \tm{\config{\subst{M}{V}{x}}{S}}
    \\
    \LabTirName{E-Unit}  & \tm{\config{\letunit{\unit}{M}}{S}}
                         & \red & \tm{\config{M}{S}}
    \\
    \LabTirName{E-Pair}  & \tm{\config{\letpair{x}{y}{\pair{V}{W}}{M}}{S}}
                         & \red & \tm{\config{\subst{\subst{M}{V}{x}}{W}{y}}{S}}
    \\
    \LabTirName{E-New}     & \tm{\config{\lvarnew}{S}}
                           & \red
                           & \tm{\config{l}{S, l \mapsto (0, \bot)}}
    \\
    \LabTirName{E-Freeze}  & \tm{\config{\lvarfreeze}{S, l \mapsto (b, d)}}
                           & \red
                           & \tm{\config{d}{S, l \mapsto (1, d)}}
    \end{array}
    \\
    \inferrule*[lab=E-Put]{
      s = (b, d)
      \\
      s' = (b, d')
      \\
      s \sqcup s' \neq \top
  }{\tm{\config{\lvarput\;l\;d'}{S, l \mapsto s}} \red
    \tm{\config{s'}{S, l \mapsto s'}}
  }
  \\
  \inferrule*[lab=E-Put-Err]{
    s = (b, d)
      \\
      s' = (b, d')
      \\
      s \sqcup s' = \top
  }{\tm{\config{\lvarput\;l\;d'}{S, l \mapsto s}} \red
    \tm{\lvarerror}
  }
  \\
  \inferrule*[lab=E-Get]{
    J \in \mathcal{J}
    \\
    d' \in J
    \\
    d' \sqsubseteq d
  }{\tm{\config{\lvarget\;l\;J}{S, l \mapsto (b, d)}} \red
    \tm{\config{d'}{S, l \mapsto (b, d)}}
  }\\
  \inferrule*[lab=E-Pair']{
    \tm{\config{M}{S}} \red \tm{\config{M'}{S'}}   
    \\
    \tm{\config{N}{S}} \red  \tm{\config{N'}{S''}}
  }{\tm{\config{\pair{M}{N}}{S}}
    \red
    \tm{\config{\pair{M'}{N'}}{S' \sqcup S''}}
  }\\
  \inferrule*[lab=E-App]{
    \tm{\config{M}{S}} \red \tm{\config{M'}{S'}}   
    \\
    \tm{\config{N}{S}} \red  \tm{\config{N'}{S''}}
  }{\tm{\config{M\;N}{S}}
    \red
    \tm{\config{M'\;N'}{S' \sqcup S''}}
  }\\
  \inferrule*[lab=E-Lift]{
    \tm{M} \red \tm{M'}   
  }{\tm{\confige{M}{S}}
    \rede
    \tm{\confige{M'}{S}}
  }\\
  
\end{mathpar}

\subsection{Syntax sugar}

\begin{mathpar}
\inferrule*[lab=T-RunLVar]{
    \seq{\ty{\Gamma}}{M}{\tyfun{\tyL{d}}{()}}
  }{\seq{\ty{\Gamma}}{\lvarrun\;M}{\tyD{d}}}
  \\
  \begin{array}{llcl}
    \LabTirName{E-RunLVar} & \tm{\lvarrun\;M}
                           & \red
                           & \tm{(\lambda l.\letunit{M\;l}{\lvarfreeze\;l})\;\lvarnew}
  \end{array}
  \end{mathpar}

\section{Metatheory of Typed $\lambda_{\text{lvar}}$ calculus}

\subsection{Translation to $\lambda_{\text{LVar}}$ from typed
  $\lambda_{\text{lvar}}$}

\definition{A translation is a function $\zeta : C \rightarrow \sigma$,
such that:

\remember{Add partial-order rules for state $s$, where $s = (b, d)$.}
\begin{itemize}
\item it should maintain the same number of steps in $C$ when translated
  into $\sigma$;
\item it should not introduce sequentialisation.
\end{itemize}
}

\begin{mathpar}
  \begin{array}{lcll}
    \zeta(\lvarerror)                       & = & \lvarerror \\
    \zeta(\config{\lvarget\;l\;J}{S})       & = & \configl{S}{\lvarget\;l\;P}
                                            & \text{where } p_1 \cong s \text{
                                              and } P \cong J \\
    \zeta(\config{\lvarput\;l\;d'}{S})      & = & \configl{S}{\lvarput_{i}\;l}
                                             & \text{where } u_{p_{i}}
                                               \coloneqq \lambda d_{i}.
                                               d \sqcup d_{i}  \\
    \zeta(\config{\lvarnew}{S})             & = & \configl{S}{\lvarnew} \\
    \zeta(\config{\lvarfreeze\;l}{S})       & = & \configl{S}{\lvarfreeze\;l} \\
    \zeta(\config{(\lambda x.M)\;V}{S})     & = & \configl{S}{(\lambda x.e)\;v} \\
    \zeta(\config{M\;N}{S})                 & = & \configl{S}{e\;e'} \\
    \zeta(\config{()}{S})                   & = & \configl{S}{()} \\
    \zeta(\config{\letunit{M}{N}}{S})       & = & \configl{S}{(\lambda ().e)\;e'} \\
    \zeta(\config{\pair{M}{N}}{S})          & = & \configl{S}{(\lambda x. \lambda y.
                                                   \lambda f. f x y)\;e\;e'} \\
    \zeta(\config{\letpair{x}{y}{M}{N}}{S}) & = & \configl{S}{e\;(\lambda x.
                                                   \lambda y. e')} \\
    \zeta(\config{M}{S, l \mapsto (0, d)})  & = & \configl{S[l \mapsto (d,
                                                  \tt{false})]}{e} \\
    \zeta(\config{M}{S, l \mapsto (1, d)})  & = & \configl{S[l \mapsto (d,
                                                  \tt{true})]}{e} \\
  \end{array}\\
\end{mathpar}

\begin{lemma}[Translation, Typed $\lambda_{\text{lvar}} \; \rightsquigarrow
  \;\lambda_{\text{LVar}}$]
  For any translation $\zeta$,
  \begin{itemize}
    \item if $C \red C'$ and $\sigma \hookrightarrow \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$;
    \item if $C \rede C'$ and $\sigma \mapsto \sigma'$ and $\zeta(C) =
      \sigma$ , then $\zeta(C') = \sigma'$.
  \end{itemize}
\end{lemma}

\begin{proof}
  By induction on the structure of $C$.

 \case{$C = \config{\lvarerror}{S}, \; \sigma = \configl{S}{\lvarerror}$.}\\
 $C$ and $\sigma$ cannot step. Hence, the translation is vacuously valid.\\

 % ----------------------

 \case{$C = \config{\lvarget\;l\;J}{S}, \; \sigma = \configl{S}{\lvarget\;l\;P}$.}\\
  Given the operational semantics, $C$ steps to $C' = \config{s'}{S, l \mapsto (b,
    d)}$.
  And given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
  $\sigma' = \configl{S}{p_2}$. Applying $\zeta (C')$, we get
  $\configl{S}{p_2}$. Hence, the translation is valid. \\

  % ----------------------

  \case{$C = \config{\lvarput\;l\;d'}{S}, \; \sigma = \configl{S}{\lvarput_{i}\;l}$.}\\
  Given the operational semantics, $C$ can either error or take a step.\\

    \subcase{$C' = \config{s'}{S, l \mapsto s'}$} \\
    Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
    $\sigma' = \configl{S}{p_2}$ if $d \sqcup d_{i} \neq \top$, which is exactly
    the same as applying $\zeta$ to $C'$. \\
    

    % ----------------------
    \subcase{$C' = \lvarerror$}\\
     Given $\lambda_{\text{LVar}}$'s operational semantics, $\sigma$ steps to
    $\sigma' = \lvarerror$ if $d \sqcup d_{i} = \top$, which is exactly
    the same as applying $\zeta$ to $C'$. \\

  Hence, the translation is valid. \\

  \case{$ C = \config{\lvarnew}{S}$, $\sigma = \configl{S}{\lvarnew}$}\\
  \case{$ C = \config{\lvarfreeze}{S}$, $\sigma = \configl{S}{\lvarfreeze}$}\\
  \case{$ C = \config{\pair{M}{N}}{S}$,
    $\sigma = \configl{S}{(\lambda x. \lambda y.\lambda f. f x y)\;e\;e'}$} \\
  \case{$ C = \config{\letpair{x}{y}{M}{N}}{S}$
    , $\sigma = \configl{S}{e' \;(\lambda x.\lambda y. e)}$} \\
  
  
\end{proof}


\subsection{Determinism}

Determinism proof as stated in Kuper'15.

\definition{Permutation}

\definition{Permutation of an expression}

\definition{Permutation of a store}

\definition{Permutation of configurations}

\lemma{Permutability}

\lemma{Internal Determinism}

\lemma{Strong Confluence}

\lemma{Confluence}

\theorem{Determinism}

\subsection{Type safety}

\theorem{Progress}

\theorem{Preservation}

\corollary{Type Safety}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
